// src/generate-backend.js
const fs = require("fs");
const path = require("path");
const { TextDecoder } = require("util");

// ---- CLI args ----
const [, , schemaPathArg, outRootArg] = process.argv;
const schemaPath = path.resolve(process.cwd(), schemaPathArg || "./out/schema.json");
const outRoot    = path.resolve(process.cwd(), outRootArg  || "./backend");

// ---- read schema (UTF-8 / UTF-16 autodetect) ----
if (!fs.existsSync(schemaPath)) {
  console.error("hiba! Nem találom a sémát:", schemaPath);
  process.exit(1);
}
const buf = fs.readFileSync(schemaPath);
let text;
if (buf[0] === 0xFF && buf[1] === 0xFE) {
  text = new TextDecoder("utf-16le").decode(buf);
} else if (buf[0] === 0xFE && buf[1] === 0xFF) {
  text = new TextDecoder("utf-16be").decode(buf);
} else {
  text = buf.toString("utf8");
}
const schema = JSON.parse(text);

// ---- ensure output dirs ----
fs.mkdirSync(outRoot, { recursive: true });
fs.mkdirSync(path.join(outRoot, "models"), { recursive: true });
fs.mkdirSync(path.join(outRoot, "routes"), { recursive: true });
fs.mkdirSync(path.join(outRoot, "db"), { recursive: true });

// --- Helpers ---
const toPascal = s => s.replace(/[_-](\w)/g, (_,c)=>c.toUpperCase()).replace(/^\w/, c=>c.toUpperCase());
const toCamel  = s => s.replace(/[_-](\w)/g, (_,c)=>c.toUpperCase()).replace(/^\w/, c=>c.toLowerCase());

function mapSqlTypeToSequelize(col) {
  const raw = col.type || "";
  const t = raw.toUpperCase();
  const m = raw.match(/\(([^)]+)\)/);      // pl. "10,2" vagy "50"
  const arg = m ? `(${m[1]})` : "";

  if (col.enumValues && col.enumValues.length) {
    const vals = col.enumValues.map(v => `'${String(v).replace(/'/g, "\\'")}'`).join(", ");
    return `DataTypes.ENUM(${vals})`;
  }
  if (t.startsWith("INT")) return "DataTypes.INTEGER";
  if (t.startsWith("BIGINT")) return "DataTypes.BIGINT";
  if (t.startsWith("SMALLINT") || t.startsWith("TINYINT")) {
    if (/TINYINT\(\s*1\s*\)/i.test(raw)) return "DataTypes.BOOLEAN"; // bool
    return "DataTypes.SMALLINT";
  }
  if (t.startsWith("DECIMAL") || t.startsWith("NUMERIC")) return `DataTypes.DECIMAL${arg}`;
  if (t.startsWith("FLOAT")) return "DataTypes.FLOAT";
  if (t.startsWith("DOUBLE")) return "DataTypes.DOUBLE";
  if (t.startsWith("CHAR(") || t.startsWith("VARCHAR(")) return `DataTypes.STRING${arg}`;
  if (t.startsWith("TEXT") || t.endsWith("TEXT")) return "DataTypes.TEXT";
  if (t.includes("BLOB")) return "DataTypes.BLOB";
  if (t.startsWith("DATE") && !t.includes("TIME")) return "DataTypes.DATEONLY";
  if (t.includes("TIME")) return "DataTypes.DATE"; // DATETIME/TIMESTAMP
  if (t.startsWith("JSON")) return "DataTypes.JSON";
  return "DataTypes.STRING";
}

function defaultVal(col) {
  if (!("default" in col)) return undefined;
  const d = col.default;
  if (d === null) return undefined;
  const upper = String(d).trim().toUpperCase();
  if (upper === "NULL") return undefined;             // ne legyen 'NULL' string
  if (upper === "CURRENT_TIMESTAMP") return "DataTypes.NOW";
  if (/^-?\d+(\.\d+)?$/.test(String(d))) return String(d); // szám
  return JSON.stringify(String(d));                   // string literal
}

function renderModel(table) {
  const className = toPascal(table.name);
  const pk = Array.isArray(table.primaryKey) ? table.primaryKey : (table.primaryKey ? [table.primaryKey] : []);

  const cols = table.columns.map(col => {
    const parts = [];
    parts.push(`${col.name}: {`);
    parts.push(`  type: ${mapSqlTypeToSequelize(col)},`);
    if (pk.includes(col.name)) parts.push(`  primaryKey: true,`);
    if (col.nullable === false) parts.push(`  allowNull: false,`);
    const dv = defaultVal(col);
    if (dv) parts.push(`  defaultValue: ${dv},`);
    if (col.comment) parts.push(`  comment: ${JSON.stringify(col.comment)},`);
    parts.push(`}`);
    return parts.join("\n");
  }).join(",\n");

  // indexes -> options.indexes
  const ix = [];
  (table.indexes || []).forEach(i =>
    ix.push(`{ name: ${JSON.stringify(i.name || ("ix_" + i.columns.join("_")))}, fields: ${JSON.stringify(i.columns)} }`)
  );
  (table.uniqueIndexes || []).forEach(u =>
    ix.push(`{ name: ${JSON.stringify(u.name || ("uq_" + u.columns.join("_")))}, unique: true, fields: ${JSON.stringify(u.columns)} }`)
  );
  const indexesProp = ix.length ? `, indexes: [\n      ${ix.join(",\n      ")}\n    ]` : "";

  return `// Auto-generated by generate-backend.js
module.exports = (sequelize, DataTypes) => {
  const ${className} = sequelize.define('${table.name}', {
    ${cols}
  }, {
    tableName: '${table.name}',
    timestamps: false${indexesProp}
  });

  ${className}.associate = (models) => {
    ${renderAssociations(table)}
  };

  return ${className};
};`;
}

function renderAssociations(table) {
  if (!table.foreignKeys || !table.foreignKeys.length) return "// nincsenek FK-k";
  return table.foreignKeys.map(fk => {
    const sourceFields = fk.columns;
    const targetTable  = fk.references.table;
    const targetFields = fk.references.columns;
    if (sourceFields.length === 1 && targetFields.length === 1) {
      const asName = toCamel(targetTable);
      return [
        `// FK ${fk.name || ("fk_"+table.name+"_"+targetTable)} (${sourceFields[0]} -> ${targetTable}.${targetFields[0]})`,
        `models['${table.name}'].belongsTo(models['${targetTable}'], {`,
        `  as: '${asName}',`,
        `  foreignKey: '${sourceFields[0]}'`,
        `});`,
        `models['${targetTable}'].hasMany(models['${table.name}'], {`,
        `  as: '${toCamel(table.name)}List',`,
        `  foreignKey: '${sourceFields[0]}'`,
        `});`
      ].join("\n");
    }
    return `// Kompozit FK kihagyva asszociációként: (${sourceFields.join(", ")}) -> ${targetTable}(${targetFields.join(", ")})`;
  }).join("\n\n");
}

function renderRoute(table) {
  const className = toPascal(table.name);
  const pk = Array.isArray(table.primaryKey) ? table.primaryKey : (table.primaryKey ? [table.primaryKey] : []);
  const pkParams = pk.map(k => `:${k}`).join("/");
  const pkWhere  = pk.length
    ? `const where = { ${pk.map(k => `${k}: req.params.${k}`).join(", ")} };`
    : `const where = {}; // nincs deklarált PK – óvatosan!`;

  const loadModelLine = `const ${className} = req.app.get('models')['${table.name}'];`;

  return `// Auto-generated CRUD for table ${table.name}
const express = require('express');
const router = express.Router();

// LIST
router.get('/', async (req, res) => {
  try {
    ${loadModelLine}
    const limit  = Math.min(Number(req.query.limit || 100), 500);
    const offset = Number(req.query.offset || 0);
    let where = {};
    if (req.query.where) {
      try { where = JSON.parse(req.query.where); } catch {}
    }
    const rows = await ${className}.findAll({ where, limit, offset });
    return res.json(rows);
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: 'LIST_FAILED' });
  }
});

// GET BY PK
router.get('/${pkParams || ":id"}', async (req, res) => {
  try {
    ${loadModelLine}
    ${pkWhere}
    const row = await ${className}.findOne({ where });
    if (!row) return res.status(404).json({ error: 'NOT_FOUND' });
    return res.json(row);
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: 'GET_FAILED' });
  }
});

// CREATE
router.post('/', async (req, res) => {
  try {
    ${loadModelLine}
    const payload = { ...req.body };
    for (const k of Object.keys(payload)) {
      if (payload[k] === '') payload[k] = null;
    }
    const created = await ${className}.create(payload);

    // Preferált visszatöltés: PK -> UNIQUE -> fallback
    ${pk.length ? `
    // PK alapján visszakérés
    const pkWhere = { ${pk.map(k => `${k}: created.${k}`).join(', ')} };
    const row = await ${className}.findOne({ where: pkWhere });
    return res.status(201).json(row || created);
    ` : ( (table.uniqueIndexes && table.uniqueIndexes[0])
      ? `
    // Első UNIQUE index alapján visszakérés
    const row = await ${className}.findOne({ where: { ${table.uniqueIndexes[0].columns.map(c => `${c}: payload.${c}`).join(', ')} } });
    return res.status(201).json(row || created);
    `
      : `
    // Fallback: nincs PK/UNIQUE információ
    return res.status(201).json(created);
    `
    )}
  } catch (e) {
    console.error(e);
    if (e.name === 'SequelizeUniqueConstraintError') {
      const detail = e.errors?.[0];
      return res.status(409).json({
        error: 'UNIQUE_VIOLATION',
        field: detail?.path || 'unknown',
        value: detail?.value,
        message: detail?.message || 'Unique constraint violated'
      });
    }
    if (e.name === 'SequelizeValidationError') {
      return res.status(400).json({
        error: 'VALIDATION_FAILED',
        details: e.errors.map(x => ({ field: x.path, message: x.message }))
      });
    }
    return res.status(400).json({ error: 'CREATE_FAILED' });
  }
});


// UPDATE BY PK
router.put('/${pkParams || ":id"}', async (req, res) => {
  try {
    ${loadModelLine}
    ${pkWhere}
    const payload = { ...req.body };
    for (const k of Object.keys(payload)) {
      if (payload[k] === '') payload[k] = null;
    }
    const [cnt] = await ${className}.update(payload, { where });
    if (!cnt) return res.status(404).json({ error: 'NOT_FOUND' });
    const row = await ${className}.findOne({ where });
    return res.json(row);
  } catch (e) {
    console.error(e);
    if (e.name === 'SequelizeUniqueConstraintError') {
      const detail = e.errors?.[0];
      return res.status(409).json({
        error: 'UNIQUE_VIOLATION',
        field: detail?.path || 'unknown',
        value: detail?.value,
        message: detail?.message || 'Unique constraint violated'
      });
    }
    if (e.name === 'SequelizeValidationError') {
      return res.status(400).json({
        error: 'VALIDATION_FAILED',
        details: e.errors.map(x => ({ field: x.path, message: x.message }))
      });
    }
    return res.status(400).json({ error: 'UPDATE_FAILED' });
  }
});

// DELETE BY PK
router.delete('/${pkParams || ":id"}', async (req, res) => {
  try {
    ${loadModelLine}
    ${pkWhere}
    const cnt = await ${className}.destroy({ where });
    if (!cnt) return res.status(404).json({ error: 'NOT_FOUND' });
    return res.status(204).end();
  } catch (e) {
    console.error(e);
    return res.status(400).json({ error: 'DELETE_FAILED' });
  }
});

module.exports = router;`;
}

function renderDbIndex() {
  // dotenv-t NE itt töltsük (dupla log elkerülése) – csak az app entry-ben
  return `// Auto-generated DB index
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize(process.env.DB_NAME, process.env.DB_USER, process.env.DB_PASS, {
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT ? Number(process.env.DB_PORT) : 3306,
  dialect: 'mysql',
  logging: false
});

const models = {};
function loadModels() {
  const fs = require('fs');
  const path = require('path');
  const modelsDir = path.join(__dirname, '..', 'models');
  for (const file of fs.readdirSync(modelsDir).filter(f => f.endsWith('.js'))) {
    const def = require(path.join(modelsDir, file));
    const mdl = def(sequelize, DataTypes);
    models[mdl.getTableName()] = mdl; // kulcs: táblanév
  }
  Object.values(models).forEach(m => { if (m.associate) m.associate(models); });
  return models;
}

module.exports = { sequelize, loadModels };`;
}

function renderApp(tables) {
  const mounts = tables.map(t => {
    const routeVar = toCamel(t.name) + "Router";
    return `const ${routeVar} = require('./routes/${t.name}.js');
app.use('/api/${t.name}', ${routeVar});`;
  }).join("\n");

  return `// Auto-generated Express app
const express = require('express');
const cors = require('cors');
const { sequelize, loadModels } = require('./db');
const dotenv = require('dotenv');
dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

const models = loadModels();
app.set('models', models);

app.get('/health', async (req, res) => {
  try {
    await sequelize.authenticate();
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ ok: false, error: 'DB_DOWN' });
  }
});

// Mount CRUD routers
${mounts}

// Extra: statisztikai végpontok
const statsRouter = require('./routes/stats.js');
app.use('/api/stats', statsRouter);

const PORT = process.env.PORT ? Number(process.env.PORT) : 3000;
app.listen(PORT, () => console.log('Múkszik, API listening on port', PORT));`;
}

